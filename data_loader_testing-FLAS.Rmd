---
title: "Automated forecasting tool for non-linear systems of equations, with wiiw DB API integration"
author: "Aleksandr Arsenev"
date: "2023-11-30"
output: html_document
---


```{r setup, include=FALSE}
#from lower chunks
library(nleqslv)
library(xfun)
library(tidyverse)
library(tidytext)
library(officer)
library(readxl)
library(xlsx)
library(stringr)
library(gsubfn)
library(sem)
library(janitor)
library(dplyr)
library(zoo)
library(stringi)
library(tibble)

select = dplyr::select
summarize = dplyr::summarize

`%!in%` <- function(x, table) {
  !x %in% table
}
```

```{r, include=FALSE}
if ("package:plyr" %in% loadedNamespaces()) {
  detach("package:plyr", unload = TRUE)
  message("Package 'plyr' was detached to avoid conflicts with 'dplyr'.")
}

knitr::opts_chunk$set(echo = TRUE)
# setwd("C:/Users/Arsenev/Desktop/PyProjects/wiiw_database_steamlit")

streamlit_output = read_excel('streamlit_out.xlsx', sheet = 1)
inputdf_colnames = colnames(streamlit_output)
inputdf_colnames = str_to_lower(inputdf_colnames)
colnames(streamlit_output) = inputdf_colnames
streamlit_USERVAR = filter(streamlit_output, lid == 'USERVAR')
streamlit_USERVAR = c(streamlit_USERVAR$variable)

streamlit_output = filter(streamlit_output, lid != 'USERVAR')
ids = as.vector(streamlit_output['lid'])
ids = c(ids$lid)
```

```{r}
get_year_range <- function(startyear_in, endyear_in) {
  # Extract year part from the "YYYYQX" format
  start_year <- as.numeric(sub("Q[1-4]", "", startyear_in))
  end_year <- as.numeric(sub("Q[1-4]", "", endyear_in))
  
  # # Get the current year
  # current_year <- as.numeric(format(Sys.Date(), "%Y"))
  # 
  # # If year is not the current year, add 1
  # if (start_year != current_year) {
  #   start_year <- start_year + 1
  # }
  # 
  # if (end_year != current_year) {
  #   end_year <- end_year + 1
  # }
  
  # Return year range
  return(c(start_year, end_year))
}


tech_streamlit_output = read_excel('streamlit_out.xlsx', sheet = 2)
tech_streamlit_output_str = tech_streamlit_output[1,1] %>% unlist()
split_result <- strsplit(tech_streamlit_output_str, "//")[[1]]
startyear_in <- split_result[1]  # Part before //
endyear_in <- split_result[2]    
year_range <- get_year_range(startyear_in, endyear_in)
print(year_range)
cutoff = endyear_in
```

```{r}
library(xml2)
library(doParallel)
library(tidyr)
library(plyr)
library(dplyr)

registerDoParallel(cores = 6) # Register parallel backend with number of cores

# Create a function to download data from the WiiW API.
get_wiiw_data <- function(id, year_range) {
  url <- paste0("http://dbglobal.wiiw.ac.at/index.php?action=data&id=", id, "&type=M&from=", year_range[1], "&to=", year_range[2])
  data <- read_xml(url) %>% as_list() %>% as_tibble() %>% unnest_wider(data) %>% unnest(cols = names(.)) %>% unnest(cols = names(.)) %>% readr::type_convert()
  
  if(nrow(data) > 0) {
    data <- cbind(lid = id, data)
    return(data)
  }
  
}

# Create a function to download metadata from the WiiW API.
get_wiiw_metadata <- function(id) {
  url <- paste0("http://dbglobal.wiiw.ac.at/index.php?action=labelref&id=", id)
  data <- read_xml(url) %>% as_list() %>% as_tibble() %>% unnest_wider(label) %>% unnest(cols = names(.)) %>% unnest(cols = names(.)) %>% readr::type_convert()
  data <- cbind(lid = id, data) %>% filter(!is.na(rlong)) %>% mutate(
    text1 = str_replace_all(URLdecode(text1), " ", "_"),
    rlong = URLdecode(rlong)
  ) %>% pivot_wider(id_cols = c("lid"), names_from = "text1", values_from = "rlong")
  return(data)
}

# get the data in parallel
get_wiiw_data_parallel <- function(ids, year_range) {
  data_list <- foreach(id = ids, .packages = 'xml2') %dopar% get_wiiw_data(id, year_range)
  return(rbindlist(data_list, fill = TRUE))
}

# get the data in parallel
get_wiiw_metadata_parallel <- function(ids) {
  metadata_list <- foreach(id = ids, .packages = 'xml2') %dopar% get_wiiw_metadata(id)
  return(rbindlist(metadata_list, fill = TRUE))
}

# rounding function to handle precision issues
round2 = function(x, n) {
  posneg = sign(x)
  z = abs(x) * 10^n
  z = z + 0.5 + sqrt(.Machine$double.eps)
  z = trunc(z)
  z = z/10^n
  z * posneg
}


# Use foreach to download multiple datasets simultaneously
data_list <- foreach(id = ids, .packages = c('xml2', 'doParallel', 'tidyr', 'plyr', 'dplyr', 'stringr')) %dopar% get_wiiw_data(id, year_range)
                     
metadata_list <- foreach(id = ids, .packages = c('xml2', 'doParallel', 'tidyr', 'plyr', 'dplyr', 'stringr')) %dopar% get_wiiw_metadata(id)

# Combine all data into a single data frame
data <- do.call(rbind, data_list)
metadata <- do.call(plyr::rbind.fill, metadata_list)

# merge
data <- merge(
  data,
  metadata,
  all = TRUE
)
```

```{r}
# Check for NA years and print the result
if (any(is.na(data$year))) {
  unknown_years <- unique(data$year[is.na(data$year)])
  cat("Unknown year(s):", paste0(unknown_years, collapse = ", "), "removed.\n")
} else {
  cat('No years fully NA.\n')
}

process_data <- function(data) {
  data <- data %>%
    group_by(lid, year) %>%
    # dplyr::mutate(month = row_number()) %>%  # Months were already there
    dplyr::mutate(quarter = ceiling(month / 3))  # Add quarter column based on month number
  
  invalid_months <- data %>%
    group_by(lid, year) %>%
    dplyr::summarise(month_count = dplyr::n()) %>%
    filter((month_count != 12 ) & (month_count != 4))
  
  if (nrow(invalid_months) > 0) {
    warning(nrow(invalid_months), " lid-months are not from 12-mo/4-q years: \n",
            paste0("[lid: ", invalid_months$lid, ", y: ", invalid_months$year, 
                   ", -", invalid_months$month_count, "]", collapse = ", "))
  }
  
  return(data)
}

data_processed <- process_data(data)

```

```{r}
names(data_processed) = tolower(names(data_processed))

shortdata <- data_processed %>%
  select(c("lid", "year", "quarter", "month", "value", "reporter", "indicator", "unit")) %>%
  mutate(indicator_unit = str_c(indicator, unit, sep = ", ")) %>%
  select(-c("indicator", "unit")) %>%
  mutate(indicator_unit = paste0("'", indicator_unit, "'")) 

# %>%
  # mutate(year = paste0(year, "Q", as.numeric(quarter)))

# # ANNUAL -- OLD
# shortdata <- data %>%
#   select(c("lid", "year", "value", "Reporter", "Indicator", "Unit")) %>%
#   mutate(indicator_unit = str_c(Indicator, Unit, sep = ", ")) %>%
#   select(-c("Indicator", "Unit")) %>%
#   mutate(indicator_unit = paste0("'", indicator_unit, "'"))


ERROR_MESSAGE <- shortdata %>%
  group_by(indicator_unit) %>%
  filter(is.na(year) | is.na(value)) %>%
  tibble::as_tibble()


if (nrow(ERROR_MESSAGE) > 0) {
  if (is.data.frame(ERROR_MESSAGE)) {
    cat("ERROR: Some data points have NA year or value. Please check (printed under this code).")
    print(as.data.frame(ERROR_MESSAGE))
  } else {
    stop("UNKNOWN ERROR: Some data points are missing year or value. Please check the data.")
  }
}
```


```{r}
gettogether = streamlit_output
gettogether$indicator = str_remove(gettogether$indicator, "\\(m\\) ")
gettogether = gettogether %>% mutate(indicator_unit = paste0('`', indicator, ", ", unit, '`'))

# calc avg/eop here
dateformat_eop_flags <- streamlit_output %>% filter(periodflag == 'eop') %>% .$lid

eop_shortdata = shortdata %>% 
  filter(lid %in% dateformat_eop_flags) %>%
  filter(month %in% c(3, 6, 9, 12))
  
avg_shortdata <- shortdata %>%
  filter(lid %!in% dateformat_eop_flags) %>% 
  group_by(lid, year, quarter) %>%
  dplyr::summarize(
    value = sum(value) / n(),
    across(-value, last)
  )

shortdata_dateformatted = rbind(eop_shortdata, avg_shortdata)
```

```{r}
trydata = left_join(shortdata_dateformatted, gettogether, by = c('lid')) %>% 
  mutate(year = paste0(year, 'Q', quarter))

trydata = trydata %>% pivot_wider(id_cols = year, names_from = variable, values_from = value)

shortdata = trydata %>% arrange(year)

for (col_name in streamlit_USERVAR) {
  shortdata[[col_name]] = NA
}

rm(list = c("trydata", "streamlit_USERVAR"))
```

DIDNT DROP NAs here, because some of the y-var columns have to be calculated first (loil = log(oil)).

################################################################################################################

SEM Calculation


# Formula Transformation
```{r}
streamlit_formulas_path = "formulas_parsed.csv"
streamlit_formulas <- read_csv(streamlit_formulas_path)
```

05.11.24 --- USING DEFAULT FOR NOW, REPLACE WITH STREAMLIT INPUT LATER
```{r}
parsed_formulas_path = "cleaned_formulas_default.docx"
word_content = read_docx(path = parsed_formulas_path)
formulas = docx_summary(word_content)
formulas <- formulas %>% filter(content_type == "paragraph") %>% dplyr::select(text) %>% filter(text != "") %>% mutate(text = str_to_lower(text))

formulas_orig = formulas
initial_data = shortdata

data = initial_data
```

```{r}
formulas = formulas_orig

lhs_vars <- formulas %>%
  mutate(lhs = str_extract(text, "^(.*?)~")) %>% 
  mutate(lhs = trimws(lhs)) %>%
  mutate(lhs = gsub("~", "", lhs)) %>%
  select(lhs) %>%
  distinct()
  
formulas = formulas %>%
  mutate(text = gsub("~", "-(", text)) %>%
  mutate(text = paste0(text, ")"))

```


```{r}
shortdata_backup = shortdata
```


```{r}
# initial_data = shortdata
# 
# xdata <- initial_data %>% 
#   filter(year < cutoff)
# 
# pred_data <- initial_data %>%
#   filter(year >= cutoff)
# 
# 
# print(cutoff)

initial_data = shortdata

# start from the start
xdata <- initial_data[1:2,]
pred_data <- initial_data[3,]
```

```{r}
eq_strs = formulas
eq_strs <- as.character(eq_strs$text)


equations_text <- paste(eq_strs, collapse = "\n")

cat("Equations to be estimated:")
for (i in 1:nrow(formulas)) {
  print(paste(formulas$text[i]))
}

```

```{r}
fileConn<-file("raw_formulas.txt")
writeLines(equations_text, fileConn)
close(fileConn)

write_csv(initial_data, 'raw_initial_data.csv')
```


## First iteration:
- cutoff at the first unknown year-quarter
- initial guess based on previous Q values

Eval-parse the non-initial variables
```{r}
initial_data_backup = initial_data

streamlit_vars_to_eval = streamlit_formulas %>%
  filter(type != 'x') %>% 
  .$variable

streamlit_vars_to_eval <- gsub("\\(", "(initial_data$", streamlit_vars_to_eval, fixed = FALSE)
parse_testval = eval(parse(text = gsub("`", "", "`lag(initial_data$imp_nom_yoy, 1)`")))
parse_testname = "`lag(initial_data$imp_nom_yoy, 1)`"
assign(parse_testname, parse_testval)


run_parse_eval = function(iters = 1) {
  
  run_df = data.frame(matrix(ncol = 0, nrow = nrow(initial_data)))
  
  for (iter in 1:iters) {

    for (i in 1:length(streamlit_vars_to_eval)) {
      out_streamlit_parsed_var_PHOLDER = tryCatch(
        {
          globalname_streamlit_parsed_var = gsub("`", "", streamlit_vars_to_eval[i])
          globalname_streamlit_parsed_var = str_remove_all(globalname_streamlit_parsed_var, "initial_data\\$")
          streamlit_parsed_var_value = eval(parse(text = gsub("`", "", streamlit_vars_to_eval[i])))
          print(globalname_streamlit_parsed_var)
          print(streamlit_parsed_var_value)
          assign(globalname_streamlit_parsed_var, streamlit_parsed_var_value, envir = .GlobalEnv)
          dataname_streamlit_parsed_var = paste0("`", globalname_streamlit_parsed_var, "`")
          run_df[[globalname_streamlit_parsed_var]] = streamlit_parsed_var_value
          
        },
        error = function(e) {
          cat("\n", "Error with var:", streamlit_vars_to_eval[i], "\n")
          cat("Error message:", conditionMessage(e), "\n")
          return(NA)
        }
      )
    }
  
  cat("Did", iter, "################################################################## \n")  
      
  }
  
  return(run_df)
  
}

run_df_out = run_parse_eval(2)
initial_data = cbind(initial_data, run_df_out)

```


```{r}

eq_test <- function(x, eq_strs) {
  for (i in 1:nrow(lhs_vars)) {
    assign(lhs_vars$lhs[i], x[i])
  }
  
  for (i in 1:ncol(exog_row)) {
    col_name <- colnames(exog_row)[i]
    var_value <- unlist(as.vector(exog_row[1, i]))

    if (!is.finite(var_value)) {
      next
    }
    
    assign(col_name, var_value, envir = .GlobalEnv)
  }
  
  eqs <- sapply(eq_strs, function(eq_str) {
    result <- tryCatch(
      {
        eval(parse(text = eq_str))
      },
      error = function(e) {
        cat("Error in equation:", eq_str, "\n")
        cat("Error message:", conditionMessage(e), "\n")
        return(rep(NA, length(x)))  # Return NA-filled vector if there's an error
      }
    )
    
    if (any(is.na(result))) {
      # cat("NA/NaN result in equation:", eq_str, "\n")
    }
    
    return(result)
  })
  
  return(eqs)
}

workdata = initial_data


workdata$dum_2022 = 1
workdata$dum_lfs = 1


cutoff_index <- which(workdata$year == cutoff) # add warnings when cutoff and date range do not intersect
workdata = workdata %>% select(-year)
exog_vars <- setdiff(colnames(workdata), lhs_vars$lhs)
exog_row <- workdata[cutoff_index, exog_vars]

ini_guess_prevdata <- workdata[cutoff_index - 1, ] %>% 
  ungroup() %>% 
  dplyr::select(any_of(str_trim(lhs_vars$lhs)))

ini_guess_v <- as.numeric(as.vector(ini_guess_prevdata))
ini_guess_v <- replace(ini_guess_v, is.na(ini_guess_v), 0)

cat("Initial guess:\n")
for (i in 1:ncol(ini_guess_prevdata)) {
  cat(colnames(ini_guess_prevdata)[i], "\n", ini_guess_v[i], "\n")
}
cat("If NAs are spotted (except year for now...), check the data. Missing series?")

exog_row

# Use nleqslv to find the solution
solution <- nleqslv(x = ini_guess_v, fn = function(x) eq_test(x, eq_strs),
                    method = "Newton", jacobian = TRUE)

solution$x

output <- data.frame(matrix(solution$x, nrow = 1))
true_colnames = colnames(ini_guess_prevdata)
colnames(output) <- true_colnames
```

```{r}
# xvec = eval(parse(text = "workdata$cons_yoy-(0.0456145417269547*workdata$wages_yoy+0.303822480054576+0.855691652862175*workdata$eu_gdp_yoy-0.0877041887377428*workdata$cpi_yoy+0.0730312627317391*workdata$loans_hh)"))
# print(xvec)
# 
# proofdata = read_excel(path ="mkd data 07.2023.xlsx")
# proofdata = proofdata %>% filter(`...1` %in% workdata$year)
# cpi_yoy = proofdata$CPI_YOY
# 
# cons_yoy=(0.0456145417269547*workdata$wages_yoy+0.303822480054576+0.855691652862175*workdata$eu_gdp_yoy-0.0877041887377428*cpi_yoy+0.0730312627317391*workdata$loans_hh)
# cons_yoy
```



# Add the forecasted dependent variables to the overall data; recalculate lags with new input available
```{r}
workdata_1 = workdata
workdata_1[cutoff_index, colnames(output)] <- output
```


# 30.10
## One-step-ahead:
- keep coeffs and equations the same
- use new prediction as initial guess
- loop through

```{r}
next_guess = solution$x
workdata_out = workdata_1

# forecast_rows = nrow(workdata_1) - cutoff_index+1
forecast_rows = 30

for (j in 1:forecast_rows) { 
  new_index <- cutoff_index + j
  exog_row <- workdata_out[new_index, ]
  
  
  next_eq_test <- function(x, eq_strs) {
    # Define Independent Vars
    for (i in 1:nrow(lhs_vars)) {
      assign(lhs_vars$lhs[i], x[i], envir = .GlobalEnv)
    }
    
    colnames <- colnames(exog_row)

    for (i in 1:ncol(exog_row)) {
      col_name = colnames[i]
      col_name = gsub("`", "", col_name)
      col_name = trimws(col_name)
      var_value = unlist(as.vector(exog_row[1, i]))
  
      if (!is.finite(var_value)) {
      next
      }
  
      # Directly assign values to names even if they are "log(something)"
      assign(colnames[i], var_value[[1]], envir = .GlobalEnv)
  
      # Check for "log(something)" and exponentiate
      if (grepl("log\\((.+)\\)", colnames[i])) {
        matches <- regmatches(colnames[i], regexpr("log\\((.+)\\)", colnames[i]))
        var_name_inside_log <- gsub("log\\((.+)\\)", "\\1", matches)
        exp_value = exp(var_value)
        if (is.finite(exp_value)) {
          assign(var_name_inside_log, exp_value, envir = .GlobalEnv)
        }
      } else {
        # For non-log variables, create both exp and log versions
        exp_value = exp(var_value)
        log_value = log(var_value)
        if (is.finite(exp_value)) {
          assign(paste0("exp(", colnames[i], ")"), exp_value, envir = .GlobalEnv)
        }
        if (is.finite(log_value)) {
          assign(paste0("log(", colnames[i], ")"), log_value, envir = .GlobalEnv)
        }
      }

      
      # NAs can be safely ignored but lets not run the thing for everything for now 
  
    }
    
    eqs <- sapply(eq_strs, function(eq_str) eval(parse(text = eq_str)))
    return(eqs)
    
    print(x)
  }
  
  
  next_solution <- nleqslv(x = next_guess, fn = function(x) next_eq_test(x, eq_strs),
                      method = "Newton", jacobian = F)
  
  
  output <- data.frame(matrix(next_solution$x, nrow = 1))
  true_colnames = colnames(ini_guess_prevdata)
  colnames(output) <- true_colnames
  # print(output)
  
  next_guess = next_solution$x
  
  workdata_out[cutoff_index + j, colnames(output)] <- output
  
  # workdata_out$cpi = exp(workdata_out$`log(cpi)`)
  # # workdata_out$emp = workdata_out$`emp/lag(emp,4)`*workdata_out$`lag(emp,4)`
  # workdata_out$emp = workdata_out$`emp/lag(emp,4)` * unlist(workdata_out$`lag(emp,4)`)
  # workdata_out$`log(emp)` = log(workdata_out$emp)
  # workdata_out$unemp = exp(workdata_out$`log(unemp)`)
  
  # for (l in 1:nrow(lags_df)) {
  #   lag_expr <- gsub("\\bworkdata_1\\$", "workdata_out$", lags_df$value[l], perl = TRUE)
  #   var_name <- gsub("\\bworkdata_out\\$", "", lag_expr, perl = TRUE)
  #   var_name <- gsub("\\s", "", var_name)
  #   
  #   # Calculate lag value for the entire column
  #   lagged_values <- with(workdata_out, eval(parse(text = lag_expr)))
  #   
  #   # Replace NA values with the calculated lagged values in the specified column
  #   workdata_out[[var_name]] <- ifelse(is.na(workdata_out[[var_name]]), lagged_values, workdata_out[[var_name]])
  # }


}

workdata_out_rounded <- workdata_out %>%
  mutate_if(is.numeric, ~round(., 2))

s.workdata_out_rounded <- workdata_out_rounded[, true_colnames]

# library(readxl)
write.xlsx(s.workdata_out_rounded, "AUTO_FORECAST_TOOL_results.xlsx")
```

